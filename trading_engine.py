"""
–¢—Ä–µ–π–¥–∏–Ω–≥–æ–≤–∏–π –¥–≤–∏–∂–æ–∫ –∑ DCA —Ç–∞ TP —Å—Ç—Ä–∞—Ç–µ–≥—ñ—è–º–∏
"""

import os
import json
import time
import signal
import sys
from dotenv import load_dotenv
from pybit.unified_trading import HTTP
from constants import TradingConstants
from utils import (
    setup_logging, format_price, format_quantity,
    calculate_quantity, calculate_tp_price, calculate_dca_prices,
    validate_config, get_api_symbol, get_api_side, get_tp_side
)

class TradingEngine:
    """
    –û—Å–Ω–æ–≤–Ω–∏–π –∫–ª–∞—Å —Ç—Ä–µ–π–¥–∏–Ω–≥–æ–≤–æ–≥–æ –¥–≤–∏–∂–∫–∞
    """

    def __init__(self):
        """–Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è —Ç—Ä–µ–π–¥–∏–Ω–≥–æ–≤–æ–≥–æ –¥–≤–∏–∂–∫–∞"""
        self.logger = setup_logging()
        load_dotenv()
        self._connect_to_exchange()

        self.is_running = False
        self.config = None
        self.start_time = None

        signal.signal(signal.SIGINT, self._signal_handler)
        signal.signal(signal.SIGTERM, self._signal_handler)

    def _connect_to_exchange(self):
        """–ü—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è –¥–æ Bybit API"""
        try:
            self.session = HTTP(
                testnet=False,
                demo=True,
                api_key=os.getenv('BYBIT_API_KEY'),
                api_secret=os.getenv('BYBIT_API_SECRET')
            )
            self.logger.info("üöÄ –¢—Ä–µ–π–¥–∏–Ω–≥–æ–≤–∏–π –¥–≤–∏–∂–æ–∫ –∑–∞–ø—É—â–µ–Ω–æ!")
            self.logger.info("üìä –ü—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è –¥–æ Bybit Demo —É—Å–ø—ñ—à–Ω–µ!")
        except Exception as e:
            self.logger.error(f"‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è: {e}")
            raise

    def _signal_handler(self, signum, frame):
        """–û–±—Ä–æ–±–∫–∞ —Å–∏–≥–Ω–∞–ª—ñ–≤ –¥–ª—è graceful shutdown"""
        self.logger.info(f"üõë –û—Ç—Ä–∏–º–∞–Ω–æ —Å–∏–≥–Ω–∞–ª {signum}. –ó–∞–∫—Ä–∏–≤–∞—î–º–æ –ø–æ–∑–∏—Ü—ñ—ó...")
        self.stop()
        sys.exit(0)

    def load_config(self):
        """–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –∫–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—ó –∑ JSON —Ñ–∞–π–ª—É"""
        try:
            with open('config.json', 'r') as f:
                self.config = json.load(f)
            validate_config(self.config)
            self.logger.info(f"‚úÖ –ö–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—è –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–∞: {self.config['symbol']}")
            return self.config
        except FileNotFoundError:
            self.logger.error("‚ùå –§–∞–π–ª config.json –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ")
            return None
        except json.JSONDecodeError as e:
            self.logger.error(f"‚ùå –ü–æ–º–∏–ª–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥—É JSON: {e}")
            return None
        except ValueError as e:
            self.logger.error(f"‚ùå –ü–æ–º–∏–ª–∫–∞ –≤–∞–ª—ñ–¥–∞—Ü—ñ—ó –∫–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—ó: {e}")
            return None

    def start(self):
        """–ó–∞–ø—É—Å–∫ —Ç–æ—Ä–≥—ñ–≤–ª—ñ"""
        if self.is_running:
            self.logger.warning("‚ö†Ô∏è –î–≤–∏–∂–æ–∫ –≤–∂–µ –ø—Ä–∞—Ü—é—î")
            return

        if not self.load_config():
            return

        self.is_running = True
        self.start_time = time.time()
        self._run_trading_loop()

    def stop(self):
        """–ó—É–ø–∏–Ω–∫–∞ —Ç–æ—Ä–≥—ñ–≤–ª—ñ –∑ –∑–∞–∫—Ä–∏—Ç—Ç—è–º –ø–æ–∑–∏—Ü—ñ–π"""
        if not self.is_running:
            self.logger.warning("‚ö†Ô∏è –î–≤–∏–∂–æ–∫ –Ω–µ –ø—Ä–∞—Ü—é—î")
            return

        self.logger.info("üõë –ó—É–ø–∏–Ω—è—î–º–æ —Ç–æ—Ä–≥—ñ–≤–ª—é...")
        self.close_all_positions()
        self.is_running = False
        self.logger.info("‚èπÔ∏è –¢–æ—Ä–≥—ñ–≤–ª—è –∑—É–ø–∏–Ω–µ–Ω–∞")

    def _run_trading_loop(self):
        """–û—Å–Ω–æ–≤–Ω–∏–π —Ü–∏–∫–ª —Ç–æ—Ä–≥—ñ–≤–ª—ñ"""
        self.logger.info("\nüöÄ –ó–ê–ü–£–°–ö –¢–†–ï–ô–î–ò–ù–ì–û–í–û–ì–û –î–í–ò–ñ–ö–ê")
        self.logger.info("=" * 50)

        current_price = self.get_current_price(self.config['symbol'])
        if not current_price:
            return

        order = self.open_position(self.config)
        if not order:
            return

        self.place_tp_orders(self.config, current_price)
        self.place_dca_orders(self.config, current_price)

        self.logger.info("\nüìä –ü–æ—á–∏–Ω–∞—î–º–æ –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥...")
        api_symbol = get_api_symbol(self.config['symbol'])

        while self.is_running:
            self.monitor_positions(api_symbol)
            time.sleep(TradingConstants.MONITORING_INTERVAL)

    def get_current_price(self, symbol):
        """–û—Ç—Ä–∏–º–∞–Ω–Ω—è –ø–æ—Ç–æ—á–Ω–æ—ó —Ü—ñ–Ω–∏ –∞–∫—Ç–∏–≤—É"""
        try:
            api_symbol = get_api_symbol(symbol)
            response = self.session.get_tickers(category=TradingConstants.CATEGORY_LINEAR, symbol=api_symbol)

            if response['retCode'] == 0 and response['result']['list']:
                price = float(response['result']['list'][0]['lastPrice'])
                self.logger.info(f"üí∞ –ü–æ—Ç–æ—á–Ω–∞ —Ü—ñ–Ω–∞ {symbol}: {format_price(price)}")
                return price
            else:
                self.logger.error(f"‚ùå –ü–æ–º–∏–ª–∫–∞ –æ—Ç—Ä–∏–º–∞–Ω–Ω—è —Ü—ñ–Ω–∏: {response}")
                return None
        except Exception as e:
            self.logger.error(f"‚ùå –ü–æ–º–∏–ª–∫–∞ –æ—Ç—Ä–∏–º–∞–Ω–Ω—è —Ü—ñ–Ω–∏: {e}")
            return None

    def open_position(self, config):
        """–í—ñ–¥–∫—Ä–∏—Ç—Ç—è –ø–æ–∑–∏—Ü—ñ—ó"""
        symbol = config['symbol']
        side = config['side']
        amount = config['market_order_amount']
        leverage = config['leverage']

        api_side = get_api_side(side)
        api_symbol = get_api_symbol(symbol)

        self.logger.info(f"ÔøΩÔøΩ –í—ñ–¥–∫—Ä–∏–≤–∞—î–º–æ –ø–æ–∑–∏—Ü—ñ—é: {side} ${amount} {symbol} (x{leverage})")

        try:
            # –í—Å—Ç–∞–Ω–æ–≤–ª—é—î–º–æ leverage
            try:
                self.session.set_leverage(
                    category=TradingConstants.CATEGORY_LINEAR,
                    symbol=api_symbol,
                    buyLeverage=str(leverage),
                    sellLeverage=str(leverage)
                )
                self.logger.info(f"‚úÖ Leverage –≤—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ: {leverage}x")
            except Exception as leverage_error:
                if "110043" in str(leverage_error):
                    self.logger.info(f"‚ÑπÔ∏è Leverage –≤–∂–µ –≤—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–π: {leverage}x")
                else:
                    self.logger.warning(f"‚ö†Ô∏è –ü–æ–º–∏–ª–∫–∞ leverage: {leverage_error}")

            current_price = self.get_current_price(symbol)
            if not current_price:
                return None

            qty = calculate_quantity(amount, current_price)
            self.logger.info(f"üí∞ –°—É–º–∞: ${amount}, –¶—ñ–Ω–∞: {format_price(current_price)}, –ö—ñ–ª—å–∫—ñ—Å—Ç—å: {format_quantity(qty)}")

            order = self.session.place_order(
                category=TradingConstants.CATEGORY_LINEAR,
                symbol=api_symbol,
                side=api_side,
                orderType=TradingConstants.ORDER_TYPE_MARKET,
                qty=str(qty),
                timeInForce=TradingConstants.TIME_IN_FORCE_IOC
            )

            self.logger.info(f"‚úÖ –ü–æ–∑–∏—Ü—ñ—è –≤—ñ–¥–∫—Ä–∏—Ç–∞: {order}")
            return order

        except Exception as e:
            self.logger.error(f"‚ùå –ü–æ–º–∏–ª–∫–∞ –≤—ñ–¥–∫—Ä–∏—Ç—Ç—è –ø–æ–∑–∏—Ü—ñ—ó: {e}")
            return None

    def place_tp_orders(self, config, current_price):
        """–†–æ–∑–º—ñ—â–µ–Ω–Ω—è TP –æ—Ä–¥–µ—Ä—ñ–≤"""
        symbol = config['symbol']
        side = config['side']
        tp_orders = config['tp_orders']

        api_symbol = get_api_symbol(symbol)
        api_side = get_tp_side(side)

        for i, tp_order in enumerate(tp_orders):
            try:
                tp_price = calculate_tp_price(current_price, tp_order['price_percent'], side)
                qty = calculate_quantity(
                    (tp_order['quantity_percent'] / 100) * config['market_order_amount'],
                    current_price
                )

                order = self.session.place_order(
                    category=TradingConstants.CATEGORY_LINEAR,
                    symbol=api_symbol,
                    side=api_side,
                    orderType=TradingConstants.ORDER_TYPE_LIMIT,
                    qty=str(qty),
                    price=str(round(tp_price, 2)),
                    timeInForce=TradingConstants.TIME_IN_FORCE_GTC
                )

                self.logger.info(
                    f"TP {i + 1}: {tp_order['price_percent']}% = ${tp_price:,.2f} ({format_quantity(qty)})")
                self.logger.info(f"‚úÖ TP {i + 1} –ø–µ—Ä–µ—Ä–∞—Ö–æ–≤–∞–Ω–æ")

            except Exception as e:
                self.logger.error(f"‚ùå –ü–æ–º–∏–ª–∫–∞ TP –æ—Ä–¥–µ—Ä–∞ {i + 1}: {e}")

    def place_dca_orders(self, config, current_price):
        """–†–æ–∑–º—ñ—â–µ–Ω–Ω—è DCA –æ—Ä–¥–µ—Ä—ñ–≤"""
        symbol = config['symbol']
        side = config['side']
        limit_orders = config['limit_orders']

        api_symbol = get_api_symbol(symbol)
        api_side = get_api_side(side)

        range_percent = limit_orders['range_percent']
        orders_count = limit_orders['orders_count']

        self.logger.info(f"üìä –°—Ç–∞–≤–∏–º–æ DCA –æ—Ä–¥–µ—Ä–∏ –¥–ª—è {symbol}...")
        self.logger.info(f"  –î—ñ–∞–ø–∞–∑–æ–Ω: {range_percent}%, –ö—ñ–ª—å–∫—ñ—Å—Ç—å: {orders_count}")

        dca_prices = calculate_dca_prices(current_price, range_percent, orders_count, side)

        for i, order_price in enumerate(dca_prices):
            try:
                qty = calculate_quantity(
                    config['limit_orders_amount'] / orders_count,
                    order_price
                )

                order = self.session.place_order(
                    category=TradingConstants.CATEGORY_LINEAR,
                    symbol=api_symbol,
                    side=api_side,
                    orderType=TradingConstants.ORDER_TYPE_LIMIT,
                    qty=str(qty),
                    price=str(order_price),
                    timeInForce=TradingConstants.TIME_IN_FORCE_GTC
                )

                self.logger.info(f"  DCA {i + 1}: ${order_price:,.2f} ({format_quantity(qty)})")
                self.logger.info(f"  ‚úÖ DCA {i + 1} –ø–æ—Å—Ç–∞–≤–ª–µ–Ω–æ")

            except Exception as e:
                self.logger.error(f"‚ùå –ü–æ–º–∏–ª–∫–∞ DCA –æ—Ä–¥–µ—Ä–∞ {i + 1}: {e}")

    def monitor_positions(self, api_symbol):
        """–ú–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥ –∑ DCA –ª–æ–≥—ñ–∫–æ—é"""
        try:
            # –û—Ç—Ä–∏–º—É—î–º–æ –ø–æ—Ç–æ—á–Ω—É –ø–æ–∑–∏—Ü—ñ—é
            current_position = self.get_current_position_info(api_symbol)

            if current_position:
                self.logger.info(f"\nüìä –ü–û–ó–ò–¶–Ü–Ø: {format_quantity(current_position['size'])}")
                self.logger.info(f"üí∞ –°–µ—Ä–µ–¥–Ω—è —Ü—ñ–Ω–∞: ${current_position['avg_price']:,.2f}")
                self.logger.info(f"üìà PnL: ${current_position['unrealised_pnl']:,.2f}")

                # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –≤–∏–∫–æ–Ω–∞–Ω—ñ –æ—Ä–¥–µ—Ä–∏
                executed_orders = self.check_executed_orders(api_symbol)

                if executed_orders:
                    self.logger.info(f"üîÑ –í–∏–∫–æ–Ω–∞–Ω–æ {len(executed_orders)} –æ—Ä–¥–µ—Ä—ñ–≤")

                    # –†–æ–∑—Ä–∞—Ö–æ–≤—É—î–º–æ –Ω–æ–≤—É —Å–µ—Ä–µ–¥–Ω—é —Ü—ñ–Ω—É
                    new_avg_price = self.calculate_new_avg_price(current_position, executed_orders)

                    if new_avg_price != current_position['avg_price']:
                        self.logger.info(f"üîÑ –ù–æ–≤–∞ —Å–µ—Ä–µ–¥–Ω—è —Ü—ñ–Ω–∞: ${new_avg_price:,.2f}")
                        self.logger.info(
                            f"‚ÜîÔ∏è –°–µ—Ä–µ–¥–Ω—è —Ü—ñ–Ω–∞ –∑–º—ñ–Ω–∏–ª–∞—Å—è: ${current_position['avg_price']:,.2f} ‚Üí ${new_avg_price:,.2f}")

                        # –ü–µ—Ä–µ—Ä–∞—Ö–æ–≤—É—î–º–æ TP –æ—Ä–¥–µ—Ä–∏
                        self.recalculate_tp_orders(self.config, new_avg_price)

            return current_position

        except Exception as e:
            self.logger.error(f"‚ùå –ü–æ–º–∏–ª–∫–∞ –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥—É: {e}")
            return None

    def recalculate_tp_orders(self, config, new_avg_price):
        """–ü–µ—Ä–µ—Ä–∞—Ö—É–Ω–æ–∫ TP –æ—Ä–¥–µ—Ä—ñ–≤ –∑ –Ω–æ–≤–æ—é —Å–µ—Ä–µ–¥–Ω—å–æ—é —Ü—ñ–Ω–æ—é"""
        symbol = config['symbol']
        side = config['side']
        total_amount = config['market_order_amount']

        # –ö–æ–Ω–≤–µ—Ä—Ç—É—î–º–æ side
        api_side = get_tp_side(side)
        api_symbol = get_api_symbol(symbol)

        self.logger.info(f"üéØ –ü–µ—Ä–µ—Ä–∞—Ö–æ–≤—É—î–º–æ TP –æ—Ä–¥–µ—Ä–∏ –∑ –Ω–æ–≤–æ—é —Ü—ñ–Ω–æ—é: ${new_avg_price:,.2f}")

        # –°–∫–∞—Å–æ–≤—É—î–º–æ —Å—Ç–∞—Ä—ñ TP –æ—Ä–¥–µ—Ä–∏
        self.cancel_tp_orders(api_symbol)

        # –°—Ç–∞–≤–∏–º–æ –Ω–æ–≤—ñ TP –æ—Ä–¥–µ—Ä–∏
        for i, tp in enumerate(config['tp_orders']):
            tp_price = calculate_tp_price(new_avg_price, tp['price_percent'], side)
            tp_amount = total_amount * (tp['quantity_percent'] / 100)
            tp_qty = calculate_quantity(tp_amount, new_avg_price)

            self.logger.info(f"TP {i + 1}: {tp['price_percent']}% = ${tp_price:,.2f} ({format_quantity(tp_qty)})")

            try:
                self.session.place_order(
                    category=TradingConstants.CATEGORY_LINEAR,
                    symbol=api_symbol,
                    side=api_side,
                    orderType=TradingConstants.ORDER_TYPE_LIMIT,
                    qty=str(tp_qty),
                    price=str(round(tp_price, 2)),
                    timeInForce=TradingConstants.TIME_IN_FORCE_GTC
                )
                self.logger.info(f"‚úÖ TP {i + 1} –ø–µ—Ä–µ—Ä–∞—Ö–æ–≤–∞–Ω–æ")
            except Exception as e:
                self.logger.error(f"‚ùå –ü–æ–º–∏–ª–∫–∞ TP {i + 1}: {e}")

    def cancel_tp_orders(self, api_symbol):
        """–°–∫–∞—Å—É–≤–∞–Ω–Ω—è –≤—Å—ñ—Ö Limit –æ—Ä–¥–µ—Ä—ñ–≤ (TP + DCA)"""
        try:
            orders = self.session.get_open_orders(category=TradingConstants.CATEGORY_LINEAR, symbol=api_symbol)
            if orders['retCode'] == 0:
                order_list = orders['result']['list']
                for order in order_list:
                    if order['orderType'] == TradingConstants.ORDER_TYPE_LIMIT:
                        self.session.cancel_order(
                            category=TradingConstants.CATEGORY_LINEAR,
                            symbol=api_symbol,
                            orderId=order['orderId']
                        )
                        self.logger.info(f"üóëÔ∏è –°–∫–∞—Å–æ–≤–∞–Ω–æ TP –æ—Ä–¥–µ—Ä: {order['orderId']}")
        except Exception as e:
            self.logger.error(f"‚ùå –ü–æ–º–∏–ª–∫–∞ —Å–∫–∞—Å—É–≤–∞–Ω–Ω—è –æ—Ä–¥–µ—Ä—ñ–≤: {e}")

    def close_all_positions(self):
        """–ó–∞–∫—Ä–∏—Ç—Ç—è –≤—Å—ñ—Ö –ø–æ–∑–∏—Ü—ñ–π"""
        if not self.config:
            return

        try:
            api_symbol = get_api_symbol(self.config['symbol'])
            side = self.config['side']

            positions = self.session.get_positions(category=TradingConstants.CATEGORY_LINEAR, symbol=api_symbol)

            if positions['retCode'] == 0:
                position_list = positions['result']['list']
                if position_list and float(position_list[0]['size']) > 0:
                    position_size = float(position_list[0]['size'])
                    close_side = "Buy" if side == "short" else "Sell"

                    self.logger.info(f"üîÑ –ó–∞–∫—Ä–∏–≤–∞—î–º–æ –ø–æ–∑–∏—Ü—ñ—é: {format_quantity(position_size)}")

                    close_order = self.session.place_order(
                        category=TradingConstants.CATEGORY_LINEAR,
                        symbol=api_symbol,
                        side=close_side,
                        orderType=TradingConstants.ORDER_TYPE_MARKET,
                        qty=str(position_size),
                        timeInForce=TradingConstants.TIME_IN_FORCE_IOC
                    )

                    if close_order['retCode'] == 0:
                        self.logger.info("‚úÖ –ü–æ–∑–∏—Ü—ñ—è —É—Å–ø—ñ—à–Ω–æ –∑–∞–∫—Ä–∏—Ç–∞")

            self.cancel_all_orders(api_symbol)

        except Exception as e:
            self.logger.error(f"‚ùå –ü–æ–º–∏–ª–∫–∞ –∑–∞–∫—Ä–∏—Ç—Ç—è –ø–æ–∑–∏—Ü—ñ–π: {e}")

    def cancel_all_orders(self, api_symbol):
        """–°–∫–∞—Å—É–≤–∞–Ω–Ω—è –≤—Å—ñ—Ö –æ—Ä–¥–µ—Ä—ñ–≤"""
        try:
            orders = self.session.get_open_orders(category=TradingConstants.CATEGORY_LINEAR, symbol=api_symbol)

            if orders['retCode'] == 0:
                order_list = orders['result']['list']
                if order_list:
                    self.logger.info(f"üîÑ –°–∫–∞—Å–æ–≤—É—î–º–æ {len(order_list)} –∞–∫—Ç–∏–≤–Ω–∏—Ö –æ—Ä–¥–µ—Ä—ñ–≤...")
                    for order in order_list:
                        try:
                            self.session.cancel_order(
                                category=TradingConstants.CATEGORY_LINEAR,
                                symbol=api_symbol,
                                orderId=order['orderId']
                            )
                            self.logger.info(f"‚ùå –°–∫–∞—Å–æ–≤–∞–Ω–æ –æ—Ä–¥–µ—Ä: {order['orderId']}")
                        except Exception as e:
                            self.logger.warning(f"‚ö†Ô∏è –ü–æ–º–∏–ª–∫–∞ —Å–∫–∞—Å—É–≤–∞–Ω–Ω—è –æ—Ä–¥–µ—Ä–∞ {order['orderId']}: {e}")
        except Exception as e:
            self.logger.error(f"‚ùå –ü–æ–º–∏–ª–∫–∞ —Å–∫–∞—Å—É–≤–∞–Ω–Ω—è –æ—Ä–¥–µ—Ä—ñ–≤: {e}")

    # –ú–µ—Ç–æ–¥–∏ –¥–ª—è –≤–µ–±-—ñ–Ω—Ç–µ—Ä—Ñ–µ–π—Å—É
    def get_status(self):
        """–û—Ç—Ä–∏–º–∞–Ω–Ω—è —Å—Ç–∞—Ç—É—Å—É –¥–≤–∏–∂–∫–∞"""
        return {
            'is_running': self.is_running,
            'start_time': self.start_time,
            'config': self.config,
            'uptime': time.time() - self.start_time if self.start_time else 0
        }

    def get_positions(self):
        """–û—Ç—Ä–∏–º–∞–Ω–Ω—è –ø–æ—Ç–æ—á–Ω–∏—Ö –ø–æ–∑–∏—Ü—ñ–π"""
        if not self.config:
            return []
        api_symbol = get_api_symbol(self.config['symbol'])
        positions = self.session.get_positions(category=TradingConstants.CATEGORY_LINEAR, symbol=api_symbol)
        if positions['retCode'] == 0:
            return positions['result']['list']
        return []

    def get_orders(self):
        """–û—Ç—Ä–∏–º–∞–Ω–Ω—è –∞–∫—Ç–∏–≤–Ω–∏—Ö –æ—Ä–¥–µ—Ä—ñ–≤"""
        if not self.config:
            return []
        api_symbol = get_api_symbol(self.config['symbol'])
        orders = self.session.get_open_orders(category=TradingConstants.CATEGORY_LINEAR, symbol=api_symbol)
        if orders['retCode'] == 0:
            return orders['result']['list']
        return []

    def get_current_position_info(self, api_symbol):
        """–û—Ç—Ä–∏–º–∞–Ω–Ω—è –ø–æ—Ç–æ—á–Ω–æ—ó —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—ó –ø—Ä–æ –ø–æ–∑–∏—Ü—ñ—é"""
        try:
            positions = self.session.get_positions(category=TradingConstants.CATEGORY_LINEAR, symbol=api_symbol)

            for pos in positions['result']['list']:
                if float(pos['size']) > 0:
                    return {
                        'size': float(pos['size']),
                        'avg_price': float(pos['avgPrice']),
                        'unrealised_pnl': float(pos['unrealisedPnl'])
                    }
            return None

        except Exception as e:
            self.logger.error(f"‚ùå –ü–æ–º–∏–ª–∫–∞ –æ—Ç—Ä–∏–º–∞–Ω–Ω—è –ø–æ–∑–∏—Ü—ñ—ó: {e}")
            return None

    def check_executed_orders(self, api_symbol):
        """–ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –≤–∏–∫–æ–Ω–∞–Ω–∏—Ö –æ—Ä–¥–µ—Ä—ñ–≤"""
        try:
            # –û—Ç—Ä–∏–º—É—î–º–æ —ñ—Å—Ç–æ—Ä—ñ—é –æ—Ä–¥–µ—Ä—ñ–≤
            order_history = self.session.get_order_history(
                category=TradingConstants.CATEGORY_LINEAR,
                symbol=api_symbol,
                limit=50
            )

            executed_orders = []

            # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –≤–∏–∫–æ–Ω–∞–Ω—ñ –æ—Ä–¥–µ—Ä–∏
            for order in order_history['result']['list']:
                if order['orderStatus'] == 'Filled':
                    executed_orders.append(order)

            return executed_orders

        except Exception as e:
            self.logger.error(f"‚ùå –ü–æ–º–∏–ª–∫–∞ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏ –æ—Ä–¥–µ—Ä—ñ–≤: {e}")
            return []

    def calculate_new_avg_price(self, current_position, executed_orders):
        """–†–æ–∑—Ä–∞—Ö—É–Ω–æ–∫ –Ω–æ–≤–æ—ó —Å–µ—Ä–µ–¥–Ω—å–æ—ó —Ü—ñ–Ω–∏"""
        if not current_position or not executed_orders:
            return current_position['avg_price'] if current_position else 0

        total_size = current_position['size']
        total_value = current_position['size'] * current_position['avg_price']

        # –î–æ–¥–∞—î–º–æ –≤–∏–∫–æ–Ω–∞–Ω—ñ –æ—Ä–¥–µ—Ä–∏
        for order in executed_orders:
            order_size = float(order['qty'])
            order_price = float(order['avgPrice'])

            total_size += order_size
            total_value += order_size * order_price

        if total_size > 0:
            new_avg_price = total_value / total_size
            return new_avg_price

        return current_position['avg_price']
